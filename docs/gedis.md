# Gedis

A simple application server, allowing you to write apps easily and expose APIs automatically through different interfaces

#### Interfaces
- **redis protocol / (tcp)** compatible with any redis client
- **websockets** to use from javascript library

#### Features

- **Apps**
    - one app per instance
    - for each app you can get a server & client using
        ```
        server = j.servers.gedis.get('test')
        server.start(background=True)
        client = j.clients.gedis.get('test')
        client.system.ping() # SHould return "PONG"
        ```

- **Clients**
    - Python (independent of server and generates everything necessary for it to run)
        ```
        client = j.clients.gedis.get({instance})
        ```
    - Web client  **`Auto generated`**
        - Load it in your web page easily by using
          ```
          <script src="{server-ip}:{websockets_port}/static/client.js">
          ```
- **DB**
    - [BCDB](./bcdb.md) DB support
    - ORM like application layer supported by [`j.data.schema` frameowrk](./schema.md)


### installation

see [recordchain install](/rc_install.md), also make sure zdb has been build.

### Test

```bash
cd $HOMEDIR/code/github/rivine/recordchain/apps/orderbook/
python3 test.py
```


## Running

#### Create new APP

- In the following example, when you are asked about `apps_dir` during server config, use something like `/tmp`
this will tell server to create your app called `example` in `/tmp`

```python
#Configure & Run server
j.servers.gedis.get('example').start(background=True, reset=True)
#Configure & Get client 
client = j.clients.gedis.get('example', reset=True)
#execute system command ping
assert client.system.ping()==b'PONG'
```

- check the dir `/tmp/example` exist
- `tmux at` and close all servers running there
- delete server config file in `/opt/var/cfg/j.servers.gedis/example.toml`

#### Load existing APP

- Loading `example` app in `/tmp`
- When you are asked for server config, set `apps_dir` into `/tmp`
- Now when gedis finds `/tmp/example` exists, it will load it

```python
#Configure & Run server
j.servers.gedis.get('example').start(background=False, reset=True)
#Configure & Get client
client = j.clients.gedis.get('example', reset=True)
#execute system command ping
assert client.system.ping()==b'PONG'
```

#### What if I want to load existing apps from `recordchain/apps` like **`orderbook`**

-  When you are asked for server config, leave `apps_dir` empty.This will set `apps_dir` to `recordchain/apps`
and then you can load apps from there


## Add models in your APP

- just create a `toml` file(s) start(s) with `schema` and add some schemas inside it
- [Example](https://github.com/rivine/recordchain/blob/master/apps/orderbook/schema.toml)
- Now when `gedis` server starts, it will create DB tables from your schemas and db tables will be available at `j.servers.gedis.latest.db.tables` if you want to access them from your app
- when you get your python client you will find `CRUD` operations in client like
    - `client.models.{db_table_name}.new()`
    - `client.models.{db_table_name}.set()`
    - `client.models.{db_table_name}.get()`
    - `client.models.{db_table_name}.find()`


## Add API to your app

- Add a python module inside your app, inside which you define a class with the same exact name as the module name
- Inside your module define functions, which represent APIs to be exposed by `gedis`
- Example
    - Every app generated by gdis will have a module called `system.py` containing some APIs to check the server running and get all info needed by client to function
    ```python
            from js9 import j

            JSBASE = j.application.jsbase_get_class()

            class system(JSBASE):

                def __init__(self):
                    JSBASE.__init__(self)

                def ping(self):
                    return "PONG"

                def ping_bool(self):
                    return True
     ```

    - This will expose in the client the functions `client.system.ping()`,`client.system.ping_bool()` that when executed will connect to server and execute them there


- For each API / function, you may sepecify `schema in` & `schema_out` if needed
    - **Schema out**
        - If you want result of function to be an object of certain type, you add extra argument to function signature called `schema_out`
        and in your docstring you define the schema for that object, or refer to another schema by its URL
        ```
        def test(schema_out):
            """
            ```out
            name = "" (S)
            nr = 0 (I)
            ```
            """
            o=schema_out.new()
            o.name = "hamdy"
            o.nr = 1
            return o
        ```

    - **Schema in**
        - You put the object name as an argument in your function signature
        - You define `in` schema in docstring

        - example
        ```
        def test(in_obj, schema_out):
            """
            some test method, which returns something easy
            ```in
            name = "" (S)
            nr = 0 (I)
            ```
            ```out
            name = "" (S)
            nr = 0 (I)
            ```
            """
            o=schema_out.new()
            o.name = in_obj.name
            o.nr = in_obj.nr
            return o
        ```
        In this case, client will expose the full function signature like `client.system.test(name="", nr=0)` and result will be an object containing `name & nr` as well
    - In `in` & `out` schemas, you may refer to another predefined schema in a `toml` file in your app, you refer to it by `URL` preceeded by `!`


        ```
        def test(wallet):
            """
            ```in
            !threeefoldtoken.wallet
            ```
            return wallet.ipaddr
        ```
    - Other examples
        - You define all the types of passed args in `in` schema
        ```
        def list_my_sell_orders(self, sortby, desc, total_items_in_page, page_number, schema_out):
            """
            ```in
                sortby = id (S) # Field name to sort with
                desc = (B) # Descending order
                total_items_in_page = 20 (I)
                page_number = 1 (I)
            ```
            ```out
                orders = (LO) !threefoldtoken.order.sell
            ```
            """
        ```


## General Picture for how Server & client work and comunicate

**Server**

- Generates code at `/opt/var/codegen/{instance}/server`
- Copies `system.py` to `/opt/var/codegen/{instance}/server` which contains system redis commands like `ping`
- Load and register commands/functions from `system.py` as well as other modules in `{apps_dir}/{instance}`
- collect schemas in toml file(s) that starts with `schema_` in `apps_dir/{instance}`
- For each schema collected 
    - create a schema file for that schema in `/opt/var/codegen/schema`
    - load schema in memory
    - create db table with the same name as schema name
    - create model file names `model_{schema_name}.py` under `/opt/var/codegen/{instance}/server` and add it to dictionary
    `j.servers.gedis.latest.db.tables`.
    - models allow for `CRUD` operations on a table

**Client**

- Creates `/opt/var/codegen/{instance}/client` directory in the 1st time
- Fetch server for all schemas loaded inside it
- Create `/opt/var/codegen/{instance}/server`
- For each schema in loaded schemas
    - create a schema file for that schema in `/opt/var/codegen/schema`
    - load schema in memory
    - create model file names `model_{schema_name}.py` under `apps_dir/{instance}/client` and add it to client instance
    in `models` property so it can be accessed through `client.models.{model_name}`
- Fetch server for each registered command
- For each namespace registered in server
    - create `/opt/var/codegen/{instance}/client/cmds_{instance}_{namespace}.py` file containign all commands in that name space
    - for each command, make sure if `schema_in` for a command is provided to expand its properties in the client command function arguments



